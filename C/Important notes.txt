Note no1:


The code you provided has an issue with the `scanf` function that causes it not to work as expected. The problem is related to how `scanf` processes input characters and newlines.

When you use `scanf` to read a character using the `%c` format specifier, it reads the next available character from the input stream, which includes any whitespace characters like spaces, tabs, or newlines. In this case, when the user enters a number followed by the Enter key, the `scanf` function reads the number as well as the newline character generated by pressing Enter.

Here's what happens during the execution of the program:

1. The program prompts the user to enter "number 1."
2. The user enters a character, let's say 'A,' and presses Enter.
3. `scanf` reads 'A' and the newline character generated by pressing Enter, but the newline is not consumed and remains in the input buffer.
4. The program then prompts the user to enter "number 2."
5. Now, since there's already a newline character in the input buffer, `scanf` immediately reads it without waiting for new input from the user.

To fix this issue, you can add a space before the `%c` format specifier in the `scanf` function. The space will consume any whitespace characters (including newlines) left in the input buffer, allowing you to read the desired character input correctly.

Here's the modified code:

```c
#include <stdio.h>

void main(void)
{
    char x, y, z, temp1;

    printf("please enter number 1: ");
    scanf(" %c", &x); // Add a space before %c to consume any whitespace characters.
    printf("please enter number 2: ");
    scanf(" %c", &y); // Add a space before %c to consume any whitespace characters.
    printf("please enter number 3: ");
    scanf(" %c", &z); // Add a space before %c to consume any whitespace characters.
    temp1 = z;
    z = x;
    x = temp1;
    printf("number 3: %c\n", x);
    printf("number 2: %c\n", y);
    printf("number 1: %c", z);
}
```

Now, when the user enters a character followed by Enter for each input prompt, the program will read the correct character and produce the expected output.




/////////////////////////////////////////////////////////////////////////////////////////////




NOTE NO2:


why in here when i wrote in first input number 34 or more than one digit number it considered the 2nd number input as an input for 2nd scanf even though char can hold numbers up to 255?

Answer:

In the code you provided, the issue occurs because you are using the `%c` format specifier in the `scanf` function to read characters, but you are entering multi-digit numbers. The `%c` format specifier is designed to read a single character, not multi-digit numbers. When you enter a multi-digit number like "34," the first digit '3' is read by the first `scanf`, and the second digit '4' is left in the input buffer.

As a result, when the program proceeds to the second `scanf`, it finds the remaining '4' in the input buffer and reads it as the second character input instead of waiting for a new input from the user.

To resolve this issue, you can use the `%d` format specifier in `scanf` to read integer numbers instead of `%c`. The `%d` format specifier is used for integer input, and it can handle multi-digit numbers correctly.

Here's the modified code:

```c
#include <stdio.h>

void main(void)
{
    int x, y, z, temp1;

    printf("please enter number 1: ");
    scanf("%d", &x);
    printf("please enter number 2: ");
    scanf("%d", &y);
    printf("please enter number 3: ");
    scanf("%d", &z);
    temp1 = z;
    z = x;
    x = temp1;
    printf("number 3: %d\n", x);
    printf("number 2: %d\n", y);
    printf("number 1: %d", z);
}
```

Now, the code will correctly read multi-digit numbers, and the program will work as expected without considering the second number input as an input for the second `scanf`.